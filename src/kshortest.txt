import java.util.ArrayList;

public class KShortestPath {

    public KShortestPath(Hypergraph H, Vertex s, Vertex t,int K)  {
        // we should use "pair" class for our priority queue
        ShortestPath sp = new ShortestPath(H,H.getVertices().get(0),H.getVertices().get(H.getVertices().size()-1));
        ArrayList<Edge> hp = sp.getShortestPath();
        Hypergraph hyperpath = new Hypergraph().edgesInput(hp);

        backBranching(H,hyperpath);
    }

    public void tempMethod(){

    }

    private ArrayList<Hypergraph> backBranching(Hypergraph hypergraph, Hypergraph hyperpath) {
        ArrayList<Hypergraph> setOfHypergraphs = new ArrayList<>();
        ArrayList<Edge> edgesFromPath = hyperpath.getEdges();
        ArrayList<Edge> edgesFromGraph = hypergraph.getEdges();

        for (int i = edgesFromPath.size()-1; i >= 0; i--) {
            Hypergraph newHypergraph = new Hypergraph().edgesInput(edgesFromGraph);
            Hypergraph hyperpathClone = new Hypergraph().edgesInput(edgesFromPath);

            Edge edge = hyperpathClone.getEdges().get(i);

            removeEdge(newHypergraph,edge);

            for (int j = edgesFromPath.size()-1; j >= i+1 ; j--) {
                fixEdge(newHypergraph,hyperpathClone.getEdges().get(j).getHead());
            }
            // DEBUG
            //debugEdges(newHypergraph);
            //debugVertices(newHypergraph);
            // DEBUG
            setOfHypergraphs.add(newHypergraph);
        }

        return setOfHypergraphs;
    }

    private void removeEdge(Hypergraph hypergraph, Edge edge){
        for (Vertex vertice :edge.getTail()) {
            ArrayList<Edge> outgoingEdges = hypergraph.getVertices().get(vertice.getId()).getOutgoing_edges();
            for (int i = 0; i < outgoingEdges.size(); i++) {
                if(outgoingEdges.get(i).getId() == edge.getId()){
                    outgoingEdges.remove(i);
                    break;
                }
            }
        }
        ArrayList<Edge> ingoing_edges = hypergraph.getVertices().get(edge.getHead().getId()).getIngoing_edges();
        for (int i = 0; i < ingoing_edges.size(); i++) {
            if(ingoing_edges.get(i).getId() == edge.getId()){
                ingoing_edges.remove(i);
                break;
            }
        }

        ArrayList<Edge> edges = hypergraph.getEdges();

        for (int i = 0; i < edges.size(); i++) {
            if(edges.get(i).getId() == edge.getId()){
                edges.remove(i);
                return;
            }
        }
    }

    private void fixEdge(Hypergraph hypergraph, Vertex vertex){
        ArrayList<Vertex> vertices = hypergraph.getVertices();
        //TODO: Problem: The outgoing edges are not change, only the ingoing, fix later
        ArrayList<Integer> vertexEdges = new ArrayList<>();
        for (Edge e :vertex.getIngoing_edges()) {
            vertexEdges.add(e.getId());
        }
        ArrayList<Integer> hyperEdges = new ArrayList<>();
        // need to make this piece much prettier, just a temporary working solution
        for (Vertex value : vertices) {
            if (value.getId() == vertex.getId()) {
                for (Edge e :value.getIngoing_edges()) {
                    hyperEdges.add(e.getId());
                }
                ArrayList<Integer> difference = new ArrayList<>();
                for (Integer i :hyperEdges) {
                    if(!vertexEdges.contains(i)){
                        difference.add(i);
                    }
                }
                for (Integer i :difference) {
                    for (Edge e :hypergraph.getEdges()) {
                        if(e.getId() == i){
                            for (Vertex v :e.getTail()) {
                                for (int j = 0; j < v.getOutgoing_edges().size(); j++) {
                                    if(v.getOutgoing_edges().get(j).getId() == i){
                                        v.getOutgoing_edges().remove(j);
                                        break;
                                    }
                                }
                            }
                            break;
                        }
                    }
                }
                value.setIngoing_edges(vertex.getIngoing_edges());
                break;
            }
        }

    }

    private void debugEdges(Hypergraph hypergraph){
        for (Edge edge :hypergraph.getEdges()) {
            System.out.println("Edge id: " + (edge.getId()+1));
        }
        System.out.println("_______");
    }

    private void debugVertices(Hypergraph hypergraph){
        System.out.println("ITEATION START ");
        System.out.println();
        for (Vertex vertex :hypergraph.getVertices()) {
            System.out.println("Vertex id: " + (vertex.getId()+1));
            if(vertex.getOutgoing_edges() != null){
                for (Edge edge: vertex.getOutgoing_edges()) {
                    System.out.println("Outgoing id: " + (edge.getId()+1));
                }
            }
            if(vertex.getIngoing_edges() != null){
                for (Edge edge: vertex.getIngoing_edges()) {
                    System.out.println("Ingoing id: " + (edge.getId()+1));
                }
            }
            System.out.println("_______");
        }
        System.out.println();
        System.out.println("ITEATION END");
    }

}

import com.sun.javafx.image.IntPixelGetter;
import javafx.util.Pair;

import java.lang.reflect.Array;
import java.lang.reflect.Parameter;
import java.util.*;

public class ShortestPath {
    //Hypergraph er det samme som hyperpath
    //Class attributes
/*    private PriorityQueue<Vertex> pq = new PriorityQueue<>(new Comparator<Vertex>() {
        @Override
        public int compare(Vertex o1, Vertex o2) {
            return Integer.compare(o1.getCost(), o2.getCost());
        }
    });*/
    private minPQ pq = new minPQ();
    private ArrayList<Edge> path = new ArrayList<>();
    private int cost = 0;

    public void printPath(){
        path.sort((o1, o2) -> o1.getId() - o2.getId());
        System.out.println("Graph printed:");
        for (Edge edge :path) {
            System.out.println("Edge id: " + (edge.getId()+1));
            System.out.println("Cost of edge: " + edge.getCost());
        }
    }

    public ShortestPath(Hypergraph hypergraph, Vertex source, Vertex target, ArrayList<Edge> deletedEdges){
        SBT(hypergraph,source,target,deletedEdges);
    }

    private ArrayList<Edge> SBT(Hypergraph hypergraph, Vertex source, Vertex target,ArrayList<Edge> deletedEdges){
        for (Vertex vertex : hypergraph.getVertices()) {
            vertex.setCost(Integer.MAX_VALUE);
        }
        for (Edge edge : hypergraph.getEdges()) {
            edge.setKj(0);
        }
        source.setCost(0);
        pq.insert(source);
        while (pq.size() > 0) {
            //debugPrintQueue();
            Vertex u = pq.popMin(); //Retrieves and removes first element
            //System.out.println("Popped: " + (u.getId()+1));
            //System.out.println("pq size: " + pq.size());
            for (Edge edge : u.getOutgoing_edges()) { // FS(u) må være u's outgoing edges
                if(deletedEdges.contains(edge)){
                    continue;
                }
                edge.setKj(edge.getKj()+1);
                if (edge.getKj() >= edge.getTail().size()) {
                    int f = minCostFunction(edge); // Some cost function
                    Vertex y = edge.getHead();
                    //System.out.println("Head: " + (y.getId()+1));
                    //System.out.println("Head cost: " + y.getCost());
                    //System.out.println("Costfunction: " + f);
                    if(y.getCost() > f){
                        // if pq doesn't contain head of current edge
                        y.setCost(f);
                        if(pq.contains(y)){
                            pq.decreaseValue(y.getId(),f);
                        }else {
                            pq.insert(y);
                        }
                        y.setPredecessor(edge);
                    }
                }
            }
            //System.out.println("________");
        }

        if(target.getCost() != Integer.MAX_VALUE){
            cost = target.getCost();
            getPath(source, target); // Array of a path of edges, perhaps return it?
            return path;
        }

        throw new IllegalArgumentException("Couldn't find a path from source to target");
    }

    /**
     * Function that takes in an edge and find the cost value for
     * the given edge, by getting the cost of all of its tail vertices
     * and adding its own cost.
     *
     * @param edge: The edge to find the cost
     * */
    private int costFunction(Edge edge){
        int edgeCost = edge.getCost();
        int edgeTailCost = 0;
        for (Vertex v : edge.getTail()) {
            edgeTailCost += v.getCost();
        }
        return edgeCost + edgeTailCost;
    }

    /**
     * Minimum cost function.
     * */
    private int minCostFunction(Edge edge){
        int edgeCost = edge.getCost();
        int edgeTailCost = Integer.MAX_VALUE;
        for (Vertex v : edge.getTail()) {
            if(v.getCost() < edgeTailCost){
                edgeTailCost = v.getCost();
            }
        }
        return edgeCost + edgeTailCost;
    }

    // not really good at finding a path maybe find a new method
    private void getPath(Vertex source, Vertex target){
        if(path.contains(target.getPredecessor())){
            return;
        }
        path.add(target.getPredecessor());
        if (target == source) {
            return;
        }
        for (Vertex vertex : target.getPredecessor().getTail()) {
            if (vertex.getPredecessor() != null) { // If the vertex doesn't have a predecessor it hasn't been visited.
                getPath(source, vertex);
            }
        }
    }

    public Pair<ArrayList<Edge>, Integer> getShortestPath(){
        path.sort((o1, o2) -> o1.getId() - o2.getId());
        return new Pair<>(path,cost);
    }

    public int getCost(){
        return cost;
    }

/*    private void debugPrintQueue(){
        ArrayList<Vertex> tmp = new ArrayList<>();
        while (pq.size() > 0){
            Vertex v = pq.poll();
            //System.out.println("Vertex id: " + (v.getId()+1));
            //System.out.println("Cost: " + v.getCost());
            tmp.add(v);
        }
        pq.addAll(tmp);
    }*/

}
